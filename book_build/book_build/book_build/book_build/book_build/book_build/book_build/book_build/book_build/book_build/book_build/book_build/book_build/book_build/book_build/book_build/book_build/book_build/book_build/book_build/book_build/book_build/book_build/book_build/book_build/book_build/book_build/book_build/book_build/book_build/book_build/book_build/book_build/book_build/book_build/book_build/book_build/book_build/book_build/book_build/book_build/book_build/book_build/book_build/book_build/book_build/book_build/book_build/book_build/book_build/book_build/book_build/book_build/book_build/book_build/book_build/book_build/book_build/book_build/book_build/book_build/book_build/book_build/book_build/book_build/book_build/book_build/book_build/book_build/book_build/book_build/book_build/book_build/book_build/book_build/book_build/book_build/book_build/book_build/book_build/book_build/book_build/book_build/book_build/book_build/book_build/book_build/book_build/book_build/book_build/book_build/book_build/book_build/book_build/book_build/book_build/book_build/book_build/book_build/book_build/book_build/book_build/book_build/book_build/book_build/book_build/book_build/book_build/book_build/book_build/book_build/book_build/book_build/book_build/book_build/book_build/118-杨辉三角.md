### [118\. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

Difficulty: **简单**

给定一个非负整数 _numRows，_生成杨辉三角的前 _numRows _行。

![https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

<small style="display: inline;">在杨辉三角中，每个数是它左上方和右上方的数的和。</small>

**示例:**

```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```

### Solution

**递归法解题**

关于杨辉三角，就不多说了，我们直接给出前三行的结果，然后先判断，如果_numRows小于等于3，就直接返回

如果大于3，那么这里利用了递归的思想，逐层递归，直到第四层开始，然后得到前三层的结果，取第三层为上一层，根据上一层计算当前层，append到前三层的列表中，返回前四层的结果，剩下的层依次类推。最终得到的是一个包含_numRows层的杨辉三角列表。

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows <= 3:
            ret = [[1], [1, 1], [1, 2, 1]]
            return ret[:numRows]
        else:
            ret = self.generate(numRows-1)
            last_layer = ret[-1]
            this_layer = [0] * numRows
            for i in range(1, numRows-1):
                this_layer[i] = last_layer[i-1] + last_layer[i]
            this_layer[0] = 1
            this_layer[-1] = 1
            ret.append(this_layer)
            return ret
```

**复杂度分析（不太确定）**

- 时间复杂度：O(_numRows^2)
- 空间复杂度：O(1) 不考虑返回值的空间

---

**数学法**

由于每一层的列表都可以通过上一层计算，那么我们可以先定义一个总的列表，然后逐层计算并append到总的列表中，直到满足_numRows的行数要求，返回。

关于当前行的计算方式，**最最关键的一点：本行元素等于上一行元素往后错一位再逐个相加**。此外，我们可以将上一行的左右两端各加一个0，会方便很多。

![](https://raw.githubusercontent.com/shmilywh/PicturesForBlog/master/2021/03/31-00-19-35-2021-03-31-00-19-31-image.png)

```python
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 0: return []
        res = [[1]]
        while len(res) < numRows:
            newRow = [a+b for a, b in zip([0]+res[-1], res[-1]+[0])]
            res.append(newRow)      
        return res
```

**复杂度分析**

- 时间复杂度：O(_numRows^2)
- 空间复杂度：O(1) 不考虑返回值的空间