### [54\. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

Difficulty: **中等**

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

**限制：**

- `0 <= matrix.length <= 100`
- `0 <= matrix[i].length <= 100`

注意：本题与主站 54 题相同：

### Solution

题意分析：

- 顺时针顺序，代表右→下→左→上
- 改变方向的条件，除了遇到已经遍历过的元素，边界元素也应该换方向
- 特殊输入的情况，比如输入为空
- 遍历的长度，应该与长x宽的总数相等，当遍历过的长度等于长x宽后，遍历结束
- 把遍历过的元素变为字符串，以做区分

```python
class Solution:
    def get_right(self, mat, i, j, nRow, nCol): 
        if j < nCol - 1 and isinstance(mat[i][j+1], int):
            return mat[i][j+1], i, j+1  
        else:
            return False, i, j

    def get_down(self, mat, i, j, nRow, nCol): 
        if i < nRow - 1  and isinstance(mat[i+1][j], int):
            return mat[i+1][j], i+1, j  
        else: 
            return False, i, j

    def get_left(self, mat, i, j, nRow, nCol): 
        if i > 0  and isinstance(mat[i-1][j], int):
            return mat[i-1][j], i-1, j  
        else:
            return False, i, j

    def get_up(self, mat, i, j, nRow, nCol): 
        if j > 0  and isinstance(mat[i][j-1], int):
            return mat[i][j-1], i, j-1
        else:
            return False, i, j

    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        # 异常情况处理
        if matrix == []: return []

        nRow, nCol = len(matrix), len(matrix[0])
        ret_list = [matrix[0][0]]
        i = j = ops_index = 0
        flags = ['right', 'down', 'left', 'up']

        while len(ret_list) < nRow * nCol:
            cur_move = getattr(self, 'get_%s'%flags[ops_index%4])
            result, new_i, new_j = cur_move(matrix, i, j, nRow, nCol)

            if isinstance(result, bool):
                ops_index += 1
                continue
            else:
                ret_list.append(result)
                matrix[i][j] = str(matrix[i][j])

            i, j = new_i, new_j
        return ret_list
```

**复杂度分析**

令 n, m 为数组长宽。

- 时间复杂度：O(nm)
- 空间复杂度：O(1) 不考虑返回数组长度